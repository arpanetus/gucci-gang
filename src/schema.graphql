type KeyValueContent { # @hasScope(scopes:["contentmanager:write", "superuser:write"]) {
  uuid: ID!
  key: String
  type: String
  value: String
  order: Int
  orderForField: String
}

type FOG { # @hasScope(scopes:["contentmanager:write", "superuser:write"]) {
  uuid: ID!
  contents: [KeyValueContent] @relation(name: "HAS_CONTENT", direction: "OUT")
  prerequisites: [FOG] @relation(name: "DEPENDS_ON", direction: "OUT")
  postrequisites: [FOG] @relation(name: "DEPENDS_ON", direction: "IN")
  partOfSog: [SOG] @relation(name: "DEPENDS_ON", direction: "IN")
}

type SOG { # @hasScope(scopes:["contentmanager:write", "superuser:write"]) {
  uuid: ID!
  contents: [KeyValueContent] @relation(name: "HAS_CONTENT", direction: "OUT")
  children: [SOG] @relation(name: "DEPENDS_ON", direction: "OUT")
  parents: [SOG] @relation(name: "DEPENDS_ON", direction: "IN")
  fogs: [FOG] @relation(name: "DEPENDS_ON", direction: "OUT")
  tagged_as: [Tag] @relation(name: "TAGGED", direction: "IN")
}

type Tag {
  uuid: ID!
  name: String
  for: [SOG] @relation(name: "TAGGED", direction: "OUT")
}

type File {
  filename: ID!
  mimetype: String!
  encoding: String!
}

scalar Upload

type Mutation {
  DeleteFileAndRemoveFromDb(filename:ID!): File # @hasScope(scopes:["contentmanager:write", "superuser:write"])
  UploadFile(file: Upload!): File! # @hasScope(scopes:["contentmanager:write", "superuser:write"])
}

type Node {
  uuid: ID!
  type: String
}

type Rel {
  from: String
  to: String
}

type RST {
  nodes: [Node]
  nodeRels: [Rel]
  nodeContents: [KeyValueContent]
  nodeContentRels: [Rel]
}

scalar Void

type Query {
  RecursiveSOGTree(uuid: ID!): RST
}


enum Role {
  simpleuser
  contentmanager
  superuser
}

type User #@isAuthenticated
{
  uuid: ID!
  name: String
  email: String
  password: String
}
